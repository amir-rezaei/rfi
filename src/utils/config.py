# src/utils/config.py

import json
import os
import numpy as np
from typing import Dict, Any


def get_config_hash(config: Dict[str, Any]) -> str:
    """
    Creates a stable, reproducible hash from a configuration dictionary.

    This is used to uniquely identify a reconstruction result for caching and
    comparison purposes. It handles numpy arrays by creating a stable
    representation of them.

    Args:
        config: The configuration dictionary to hash.

    Returns:
        A string representing the hash of the dictionary.
    """

    def custom_serializer(obj: Any) -> Any:
        """Custom JSON serializer for objects not natively supported, like numpy arrays."""
        if isinstance(obj, np.ndarray):
            # Create a simple, stable representation for hashing purposes
            return {'__ndarray__': True, 'shape': obj.shape, 'sum': obj.sum()}
        try:
            return str(obj)
        except TypeError:
            # Fallback for any other unserializable objects
            return "unserializable"

    # Create a copy to avoid modifying the original dict
    stable_config = config.copy()
    # Remove transient keys that shouldn't affect the hash
    stable_config.pop('reconstruct_button', None)

    # Dump to a sorted JSON string to ensure order doesn't affect the hash
    config_str = json.dumps(stable_config, sort_keys=True, default=custom_serializer)

    return str(hash(config_str))


def convert_ui_to_terminal_config(ui_config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Converts the flat UI config dict to the nested format for TerminalConfig.

    This function acts as an adapter between the flat dictionary generated by
    the Streamlit UI widgets and the structured dictionary expected by the
    TerminalConfig dataclass constructor.

    Args:
        ui_config: The flat dictionary from the terminal configuration UI.

    Returns:
        A nested dictionary matching the TerminalConfig constructor's signature.
    """
    return {
        'tx_power': ui_config.get('tx_power'),
        'frequency': ui_config.get('frequency'),
        'tx_array_size': f"{ui_config.get('tx_size_x')}x{ui_config.get('tx_size_y')}",
        'rx_array_size': f"{ui_config.get('rx_size_x')}x{ui_config.get('rx_size_y')}",
        'position': (ui_config.get('terminal_x'), ui_config.get('terminal_y'), ui_config.get('terminal_z')),
        'orientation': (ui_config.get('elevation'), ui_config.get('azimuth'), ui_config.get('tilt')),
        'tx_offset': (ui_config.get('tx_offset_x'), ui_config.get('tx_offset_y'), ui_config.get('tx_offset_z')),
        'rx_offset': (ui_config.get('rx_offset_x'), ui_config.get('rx_offset_y'), ui_config.get('rx_offset_z')),
        'tx_spacing': (ui_config.get('tx_spacing_x'), ui_config.get('tx_spacing_y')),
        'rx_spacing': (ui_config.get('rx_spacing_x'), ui_config.get('rx_spacing_y')),
    }


def get_recon_display_name(config: Dict[str, Any]) -> str:
    """
    REIMPLEMENTED: Creates a detailed, human-readable name from a reconstruction
    configuration, updated for the new simplified UI.

    This is used for labeling plots and UI elements, providing a concise
    summary of the algorithm and its key parameters.

    Args:
        config: The reconstruction configuration dictionary from the new UI.

    Returns:
        A formatted string for display.
    """
    method = config.get('method', 'N/A')
    name = f"{method}"
    params = []

    if method == "LASSO":
        # For LASSO, display alpha, wavelet name, and level.
        if 'alpha' in config:
            params.append(f"α={config['alpha']:.2e}")
        if 'wavelet_name' in config:
            params.append(f"wav={config.get('wavelet_name', 'db4')}")
        if 'wavelet_level' in config:
            params.append(f"lvl={config.get('wavelet_level', 2)}")

    elif method == "NN-Prior (OAMP)":
        # For NN-Prior, display the penalty weight and model name.
        if 'mu_penalty' in config:
            params.append(f"μ={config['mu_penalty']:.2f}")
        if config.get('nn_model_path'):
            # Extract just the filename for a cleaner display.
            model_name = os.path.basename(config['nn_model_path'])
            # Truncate long model names for display purposes.
            if len(model_name) > 20:
                model_name = model_name[:17] + "..."
            params.append(f"model={model_name}")

    # For Back Projection, no parameters are added to the name.

    if params:
        name += f" ({', '.join(params)})"

    return name
